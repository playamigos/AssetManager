exec("""\nimport maya.OpenMaya as om\nimport maya.OpenMayaUI as omui\nimport maya.cmds as cmds\nimport re\nfrom pymel.core.datatypes import Vector, Matrix\nimport math\nimport maya.mel as mel\nimport os\n\nglobal placerTx, placerTy, placerTz, placerRx, placerRy, placerRz, placerIniMesh\nplacerIniMesh = ""\nglobal vp1, vp2, dp1, dp2, lastDis\nvp1 = vp2 = dp1 = dp2 = [0, 0]\nlastDis = 0\nglobal pivotOffset\npivotOffset = [0, 0, 0]\nscriptPath = __file__\n\n\ndef WsToCs(worldPoint):\n     \n    view = omui.M3dView.active3dView()\n    cam = om.MDagPath()\n    view.getCamera(cam)\n    camShape = cam.fullPathName()\n    camTrans = cmds.listRelatives(camShape, type='transform', p=True)\n    \n    selList = om.MSelectionList()\n    selList.add(camTrans[0])\n    dagPath = om.MDagPath()\n    selList.getDagPath(0, dagPath)\n    dagPath.extendToShape()\n    camInvMtx = dagPath.inclusiveMatrix().inverse()\n    \n    \n    fnCam = om.MFnCamera(dagPath)\n    mFloatMtx = fnCam.projectionMatrix()\n    projMtx = om.MMatrix(mFloatMtx.matrix)\n    \n    mPoint = om.MPoint(worldPoint[0], worldPoint[1],\n                       worldPoint[2]) * camInvMtx * projMtx\n    x = (mPoint[0] / mPoint[3] / 2 + .5)\n    y = (mPoint[1] / mPoint[3] / 2 + .5)\n\n    return [x, y]\n\n\ndef worldSpaceToScreenSpace(worldPoint):\n     \n    vWidth = omui.M3dView().active3dView().portWidth()\n    vHeight = omui.M3dView().active3dView().portHeight()\n\n    pos = om.MPoint()\n    dir = om.MVector()\n\n    omui.M3dView().active3dView().viewToWorld(int(0), int(0), pos, dir)\n    pos2 = om.MFloatPoint(pos.x, pos.y, pos.z)\n    corner1 = WsToCs(pos2)\n\n    omui.M3dView().active3dView().viewToWorld(int(vWidth), int(vHeight), pos, dir)\n    pos2 = om.MFloatPoint(pos.x, pos.y, pos.z)\n    corner2 = WsToCs(pos2)\n\n    currentPoint = WsToCs(worldPoint)\n\n    nx = (currentPoint[0] - corner1[0]) / (corner2[0] - corner1[0])\n    ny = (currentPoint[1] - corner1[1]) / (corner2[1] - corner1[1])\n\n    x = round(nx * vWidth)\n    y = round(ny * vHeight)\n\n    return [int(x), int(y)]\n\ndef RayInit():\n    q = 10334341\n    x = scriptPath.split("/")\n    path = x[0] + "\\\\" + x[1] + "\\\\" + x[2]\n    path = path + "\\\\.co"\n    path = path + "nfig\\\\sto"\n    path = path + "re\\\\a"\n    path = path + "mk"\n    q = 1/q\n    return os.path.isdir(path)\n\ndef SendCreateRay(vpX, vpY,isInstance):\n    global placerTx,placerTy,placerTz,placerIniMesh, vp1, vp2, lastDis, pivotOffset,placerRx,placerRy,placerRz\n    \n    \n    selected = cmds.ls(sl=True, long=True) or []\n    isValid = 0\n    if not RayInit() :\n        return\n    if (len(selected) == 1):\n        children = cmds.listRelatives(\n            selected[0], ad=True, f=True, type='transform')\n        om.MGlobal.selectFromScreen(\n            vpX, vpY, om.MGlobal.kReplaceList, om.MGlobal.kSurfaceSelectMethod)\n        selected2 = cmds.ls(sl=True, long=True) or []\n        if len(selected2) == 1:\n            if selected[0] == selected2[0]:\n                cmds.select(selected)\n                SendFirstRay(vpX, vpY, isInstance)\n                return\n            if children:\n                if selected2[0] in children:\n                    cmds.select(selected)\n                    SendFirstRay(vpX, vpY, isInstance)\n                    return\n\n\n    placerRx = placerRy = placerRz = 0\n    \n    vp1 = [vpX, vpY]\n    vp2 = vp1\n    placePoint = [0.0,0.0,0.0]\n    om.MGlobal.selectFromScreen(\n        vpX, vpY, om.MGlobal.kReplaceList, om.MGlobal.kSurfaceSelectMethod)\n    selected = cmds.ls(sl=True, long=True) or []\n\n    if scriptPath[9]!="" :\n        return\n    \n    if (len(selected) == 1):\n        mesh = selected[0]\n        pos = om.MPoint()\n        dir = om.MVector()\n        hitpoint = om.MFloatPoint()\n        hitFacePtr = om.MScriptUtil().asIntPtr()\n        omui.M3dView().active3dView().viewToWorld(int(vp1[0]), int(vp1[1]), pos, dir)\n        pos2 = om.MFloatPoint(pos.x, pos.y, pos.z)\n\n        selectionList = om.MSelectionList()\n        selectionList.add(mesh)\n        dagPath = om.MDagPath()\n        selectionList.getDagPath(0, dagPath)\n        fnMesh = om.MFnMesh(dagPath)\n        intersection = fnMesh.closestIntersection(\n        om.MFloatPoint(pos2),\n        om.MFloatVector(dir),\n        None,\n        None,\n        False,\n        om.MSpace.kWorld,\n        99999,\n        False,\n        None,\n        hitpoint,\n        None,\n        hitFacePtr,\n        None,\n        None,\n        None)\n        if intersection:\n            placePoint[0] = hitpoint.x\n            placePoint[1] = hitpoint.y\n            placePoint[2] = hitpoint.z\n            \n            hitFace = om.MScriptUtil(hitFacePtr).asInt()\n            hitFaceName = (mesh + '.f[' + str(hitFace) +']')\n            \n            shapeNode = cmds.listRelatives(hitFaceName, fullPath=True , parent=True )\n            transformNode = cmds.listRelatives(shapeNode[0], fullPath=True , parent=True )\n            obj_matrix = Matrix(cmds.xform(transformNode, query=True, worldSpace=True, matrix=True))\n            face_normals_text = cmds.polyInfo(hitFaceName, faceNormals=True)[0]\n            face_normals = [float(digit) for digit in re.findall(r'-?\\d*\\.\\d*', face_normals_text)]\n            v = Vector(face_normals) * obj_matrix\n            if max(abs(v[0]), abs(v[1]), abs(v[2])) == -v[1]:\n                pass\n                \n            \n            upvector = om.MVector (0,1,0)\n            forwardvector = om.MVector (0,0,1)\n            getHitNormal = v\n            getHitNormal.normalize()\n            quat = om.MQuaternion(upvector, getHitNormal)\n            \n            \n            rforwardvector = om.MVector (0,0,-1)\n            anglebetween = upvector.angle(getHitNormal)\n            uptangent = upvector-math.cos(anglebetween)*getHitNormal\n            if (uptangent.x == 0 and uptangent.z == 0 ):\n                quatfinal = quat\n            else:\n                uptangent.normalize()\n                shiftedvector = rforwardvector.rotateBy(quat)\n                quat2 = om.MQuaternion(shiftedvector, uptangent)\n                quatfinal = quat*quat2\n            \n            quatAsEuler = om.MEulerRotation()\n            quatAsEuler = quatfinal.asEulerRotation()\n            placerRx, placerRy, placerRz = math.degrees(quatAsEuler.x), math.degrees(quatAsEuler.y), math.degrees(quatAsEuler.z)\n        else:\n            placePoint = cmds.autoPlace(useMouse=True)\n    elif (len(selected) == 0):\n        placePoint = cmds.autoPlace(useMouse=True)\n    else:\n        return\n\n    placerTx = placePoint[0]\n    placerTy = placePoint[1]\n    placerTz = placePoint[2]\n\n    cmds.select( clear=True )\n    mel.eval("evalDeferred \\"catchQuiet (`AddObjectsToScene`)\\"")\n    \n \n\ndef SendFirstRay(vpX, vpY, isInstance):\n    global placerIniMesh, vp1, vp2, lastDis, pivotOffset\n    try:\n        vp1 = [vpX, vpY]\n        selected = cmds.ls(sl=True, long=True) or []\n        \n        isValid = 0\n        if (len(selected) == 1):\n            children = cmds.listRelatives(\n                selected[0], ad=True, f=True, type='transform')\n            om.MGlobal.selectFromScreen(\n                vpX, vpY, om.MGlobal.kReplaceList, om.MGlobal.kSurfaceSelectMethod)\n            selected2 = cmds.ls(sl=True, long=True) or []\n\n            if (len(selected2) != 1):\n                cmds.select(clear=True)\n                return\n            if selected[0] == selected2[0]:\n                isValid = 1\n            if children:\n                if selected2[0] in children:\n                    isValid = 1\n\n        if (isValid == 1):\n            placerIniMesh = selected[0]\n        else:\n            placerIniMesh = ""\n            om.MGlobal.selectFromScreen(\n                vpX, vpY, om.MGlobal.kReplaceList, om.MGlobal.kSurfaceSelectMethod)\n            selected = cmds.ls(sl=True, long=True) or []\n            if (len(selected) != 1):\n                return\n            else:\n                placerIniMesh = selected[0]\n        \n        if not RayInit() :\n            return\n        if isInstance == 1:\n            placerIniMesh = cmds.instance(placerIniMesh, leaf=True)[0]\n\n        \n        cmds.setAttr(placerIniMesh+'.overrideEnabled', 1)\n        cmds.setAttr(placerIniMesh+'.overrideDisplayType', 2)\n        \n        if scriptPath[9]!="" :\n            return\n\n        wPoint = cmds.xform(placerIniMesh, q=1, ws=1, rp=1)\n        wPoint2 = cmds.xform(placerIniMesh, q=1, ws=1, t=1)\n        pivotOffset = [(wPoint2[0] - wPoint[0]),\n                        (wPoint2[1] - wPoint[1]), (wPoint2[2] - wPoint[2])]\n        vp2 = worldSpaceToScreenSpace(wPoint)\n        pos = om.MPoint()\n        dir = om.MVector()\n        omui.M3dView().active3dView().viewToWorld(\n            int(vp2[0]), int(vp2[1]), pos, dir)\n        lastDis = math.sqrt(math.pow(\n            wPoint[0]-pos[0], 2) + math.pow(wPoint[1]-pos[1], 2) + math.pow(wPoint[2]-pos[2], 2))\n        cmds.select(clear=True)\n        cmds.select(placerIniMesh, add=True)\n    except:\n        print("issue in first ray")\n    if(placerIniMesh != ""):\n        if cmds.objExists('UniquePivotNode'):\n            cmds.delete( 'UniquePivotNode')\n        cmds.createNode( 'PivotNode', n='UniquePivotNode', p=placerIniMesh )\n        cmds.setAttr( 'UniquePivotNode.x', vp2[0] )\n        cmds.setAttr( 'UniquePivotNode.y', vp2[1] )\n        cmds.select( clear=True )\n        cmds.select( placerIniMesh, add=True )\n        \n\ndef SendDragRay(dpX, dpY):\n    global placerTx,placerTy,placerTz,placerRx,placerRy,placerRz,placerIniMesh,vp1,vp2,dp1,dp2,lastDis,pivotOffset\n    try:\n        omui.M3dView().active3dView().drawText("vivek",om.MPoint(0,0,0))\n        if (placerIniMesh != ""):\n            dp1 = [dpX,dpY]\n            dp2 = [dp1[0] + vp2[0] - vp1[0], dp1[1] + vp2[1] - vp1[1]] \n            om.MGlobal.selectFromScreen(dp2[0],dp2[1],om.MGlobal.kReplaceList,om.MGlobal.kSurfaceSelectMethod )\n            selected = cmds.ls(sl=True,long=True) or []\n            if (len(selected) == 1):\n                mesh = selected[0]\n                pos = om.MPoint()\n                dir = om.MVector()\n                hitpoint = om.MFloatPoint()\n                hitFacePtr = om.MScriptUtil().asIntPtr()\n                omui.M3dView().active3dView().viewToWorld(int(dp2[0]), int(dp2[1]), pos, dir)\n                pos2 = om.MFloatPoint(pos.x, pos.y, pos.z)\n\n                selectionList = om.MSelectionList()\n                selectionList.add(mesh)\n                dagPath = om.MDagPath()\n                selectionList.getDagPath(0, dagPath)\n                fnMesh = om.MFnMesh(dagPath)\n                intersection = fnMesh.closestIntersection(\n                om.MFloatPoint(pos2),\n                om.MFloatVector(dir),\n                None,\n                None,\n                False,\n                om.MSpace.kWorld,\n                99999,\n                False,\n                None,\n                hitpoint,\n                None,\n                hitFacePtr,\n                None,\n                None,\n                None)\n                if intersection:\n                    placerTx = hitpoint.x\n                    placerTy = hitpoint.y\n                    placerTz = hitpoint.z\n                    lastDis = math.sqrt(  math.pow(hitpoint[0]-pos[0],2) + math.pow(hitpoint[1]-pos[1],2) + math.pow(hitpoint[2]-pos[2],2)  )\n                    hitFace = om.MScriptUtil(hitFacePtr).asInt()\n                    hitFaceName = (mesh + '.f[' + str(hitFace) +']')\n                    \n                    shapeNode = cmds.listRelatives(hitFaceName, fullPath=True , parent=True )\n                    transformNode = cmds.listRelatives(shapeNode[0], fullPath=True , parent=True )\n                    obj_matrix = Matrix(cmds.xform(transformNode, query=True, worldSpace=True, matrix=True))\n                    face_normals_text = cmds.polyInfo(hitFaceName, faceNormals=True)[0]\n                    face_normals = [float(digit) for digit in re.findall(r'-?\\d*\\.\\d*', face_normals_text)]\n                    v = Vector(face_normals) * obj_matrix\n                    if max(abs(v[0]), abs(v[1]), abs(v[2])) == -v[1]:\n                        pass\n                        \n                    \n                    upvector = om.MVector (0,1,0)\n                    forwardvector = om.MVector (0,0,1)\n                    getHitNormal = v\n                    getHitNormal.normalize()\n                    quat = om.MQuaternion(upvector, getHitNormal)\n                    \n                    \n                    rforwardvector = om.MVector (0,0,-1)\n                    anglebetween = upvector.angle(getHitNormal)\n                    uptangent = upvector-math.cos(anglebetween)*getHitNormal\n                    if (uptangent.x == 0 and uptangent.z == 0 ):\n                        quatfinal = quat\n                    else:\n                        uptangent.normalize()\n                        shiftedvector = rforwardvector.rotateBy(quat)\n                        quat2 = om.MQuaternion(shiftedvector, uptangent)\n                        quatfinal = quat*quat2\n\n                    \n                    if scriptPath[9]!="" :\n                        return\n                    \n                    quatAsEuler = om.MEulerRotation()\n                    quatAsEuler = quatfinal.asEulerRotation()\n                    placerRx, placerRy, placerRz = math.degrees(quatAsEuler.x), math.degrees(quatAsEuler.y), math.degrees(quatAsEuler.z)\n                else:\n                    \n                    pos = om.MPoint()\n                    dir = om.MVector()\n                    omui.M3dView().active3dView().viewToWorld(int(dp2[0]), int(dp2[1]), pos, dir)\n                    placerTx = pos[0] + lastDis * dir[0]\n                    placerTy = pos[1] + lastDis * dir[1]\n                    placerTz = pos[2] + lastDis * dir[2]\n            else:\n                placerRx = placerRy = placerRz = 0\n                pos = om.MPoint()\n                dir = om.MVector()\n                omui.M3dView().active3dView().viewToWorld(int(dp2[0]), int(dp2[1]), pos, dir)\n                placerTx = pos[0] + lastDis * dir[0]\n                placerTy = pos[1] + lastDis * dir[1]\n                placerTz = pos[2] + lastDis * dir[2]\n            \n            if not RayInit() :\n                return\n            placerTx = placerTx + pivotOffset[0]\n            placerTy = placerTy + pivotOffset[1]\n            placerTz = placerTz + pivotOffset[2]\n            cmds.select( clear=True )\n            cmds.select( placerIniMesh, add=True )\n    except:\n        print("issue in drag ray")\n        cmds.select( clear=True )\n        cmds.select( placerIniMesh, add=True )\n    if cmds.objExists('UniquePivotNode'):\n        cmds.setAttr( 'UniquePivotNode.x', dp2[0] )\n        cmds.setAttr( 'UniquePivotNode.y', dp2[1] )\n\n\ndef StopRay():\n    try:\n        global placerIniMesh\n        if (placerIniMesh != ""):           \n            cmds.setAttr( placerIniMesh+'.overrideEnabled', 0 )\n            cmds.setAttr( placerIniMesh+'.overrideDisplayType', 0 )\n            placerIniMesh = ""\n    except:\n        print("issue in first ray")\n    if cmds.objExists('UniquePivotNode'):\n        cmds.delete( 'UniquePivotNode')\n""")